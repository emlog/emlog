<?php
/**
 * MySQL PDO
 *
 * @package EMLOG
 * @link https://www.emlog.net
 */

class Mysqlpdo {
	/**
	 * Internal instance object
	 * @var object MySql
	 */
	private static $instance = null;

	/**
	 * Number of queries
	 * @var int
	 */
	private $queryCount = 0;

	/**
	 * Internal data connection object
	 * @var PDO
	 */
	private $conn;

	/**
	 * Internal data results
	 */
	private $result;

	private function __construct() {
		if (!class_exists('PDO')) {
/*vot*/		emMsg(lang('pdo_not_supported'));
		}

		try {
			$dsn = 'mysql:host=' . DB_HOST . ';dbname=' . DB_NAME . ';charset=utf8mb4';
			$options = [];
			$dbh = new PDO($dsn, DB_USER, DB_PASSWD, $options);
/*vot*/			$dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);   //Set if the sql statement is executed incorrectly, an exception will be thrown, and the transaction will be automatically rolled back
/*vot*/			$dbh->setAttribute(PDO::ATTR_EMULATE_PREPARES, false);           //Disable the simulation effect of prepared statements (anti-SQL injection)

			$this->conn = $dbh;
		} catch (PDOException $e) {
/*vot*/			emMsg(lang('pdo_connect_error' . $e->getMessage());
		}

	}

	/**
	 * Return the database connection instance
	 */
	public static function getInstance() {
		if (self::$instance === null) {
			self::$instance = new mysqlpdo();
		}

		return self::$instance;
	}


	/**
	 * Close database connection
	 */
	function close() {
		if (!is_null($this->conn)) {
			$this->conn = null;
		}
	}

	/**
	 * Send query
	 */
	function query($sql, $ignore_err = FALSE) {

		try {
			$this->result = $this->conn->query($sql);
			$this->queryCount++;
			if (!$ignore_err && 1046 == $this->geterrno()) {
/*vot*/				emMsg(lang('db_error_name');
			}
			if (!$ignore_err && !$this->result) {
/*vot*/				emMsg(lang('db_sql_error') . ": {$sql}<br />" . $this->geterror());
			} else {
				return $this->result;
			}
		} catch (\PDOException $e) {
			return $e->getMessage();
		}

	}

	/**
	 * Get a row from the result set as an associative array/digital index array
	 */
	function fetch_array($query, $type = PDO::FETCH_ASSOC) {

		return $query->fetch($type);

	}

	/**
	 * Take a row from the result level
	 * @param $sql
	 * @return mixed
	 */
	function once_fetch_array($sql) {
		try {
			$result = $this->conn->query($sql);

			$resultDb = $result->fetchAll(PDO::FETCH_ASSOC);
			return $resultDb[0] ?? [];
		} catch (\PDOException $e) {
			emMsg($e->getMessage());
		}

	}

	/**
	 * Get a row from the result set as a numeric index array
	 */
	function fetch_row($query) {
		return $query->rowCount();
	}

	/**
	 * Get the number of rows
	 *
	 */
	function num_rows($query) {
		$rows = $query->fetch(PDO::FETCH_NUM);
		return $rows[0] ?? 0;
	}

	/**
	 * Get the number of fields in the result set
	 */
	function num_fields($query) {
		return $query->fetchColumn();
	}

	/**
	 * Get the ID generated by the previous INSERT operation
	 */
	function insert_id() {
		return $this->conn->lastInsertId();
	}

	/**
	 * Get mysql error
	 */
	function geterror() {
		return $this->conn->errorInfo();
	}

	/**
	 * Get mysql error code
	 */
	function geterrno() {
		return $this->conn->errorCode();
	}

	/**
	 * Get number of affected rows in previous MySQL operation
	 */
	function affected_rows() {

		if ($this->result) {
			return $this->result->rowCount();
		}
		return 0;
	}

	/**
	 * Get database version information
	 */
	function getMysqlVersion() {
		return $this->conn->query('select version()')->fetchColumn();
	}

	/**
	 * Get the number of database queries
	 */
	function getQueryCount() {
		return $this->queryCount;
	}

	/**
	 *  Escapes special characters
	 */
	function escape_string($sql) {
		return trim($sql);
	}
}
